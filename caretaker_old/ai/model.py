
import re
import datetime
import logging
import ollama

# Assume the logger is set up at the top of the file
logger = logging.getLogger("ai")

class Model:
    def __init__(self, model_info, client=None):
        """
        Initializes the Model instance.

        Args:
            model_info (dict): Dictionary containing model parameters and metadata.
        """
        if client:
            self.client=client
        else:
            self.client=ollama
        self.model_info = model_info
        self.score_adjustments = []
        self.failures = 0

        logger.info(f"Initializing Model instance with model_info: {model_info}")

        self.base_score = self._calculate_base_score()

    def get(self,x):
        return self.model_info.get(x,'')
    
    def _calculate_base_score(self):
        """
        Calculates the base score based on model parameters.

        Returns:
            float: The calculated base score.
        """
        score = 0

        model_name = self.model_info.get('name', 'Unknown')
        logger.debug(f"Calculating base score for model: {model_name}")

        # Age factor: newer models get higher base score
        today = datetime.date.today()
        release_date = self.model_info.get('release_date', today)
        try:
            if not isinstance(release_date, datetime.date):
                release_date = datetime.datetime.strptime(release_date, '%Y-%m-%d').date()
            age_in_days = (today - release_date).days
        except Exception as e:
            logger.error(f"Error parsing release_date: {e}")
            age_in_days = 0  # Default to 0 if date parsing fails

        age_factor = max(0, 100 - age_in_days * 0.01)  # Models lose 0.01 point per day
        score += age_factor
        logger.debug(f"Age factor ({age_in_days} days old): {age_factor}")

        # Model size factor
        model_size = self.model_info.get('model_size', 0)  # in billions of parameters
        size_factor = model_size * 10  # Each billion parameters adds 10 points
        score += size_factor
        logger.debug(f"Model size factor ({model_size}B parameters): {size_factor}")

        # Performance metrics factor
        performance_metrics = self.model_info.get('performance_metrics', {})
        accuracy = performance_metrics.get('accuracy', 0)
        speed = performance_metrics.get('speed', 0)
        accuracy_factor = accuracy * 50  # Accuracy contributes up to 50 points
        speed_factor = speed * 10        # Speed contributes up to 10 points
        score += accuracy_factor
        score += speed_factor
        logger.debug(f"Accuracy factor ({accuracy}): {accuracy_factor}")
        logger.debug(f"Speed factor ({speed}): {speed_factor}")

        logger.info(f"Calculated base score for model {model_name}: {score}")

        # Cap the base score if necessary
        return score

    def execute_prompt(self, prompt):
        """
        Executes a prompt using the LLM model and returns the text output.

        Args:
            prompt (str): The input prompt to send to the LLM.

        Returns:
            str: The text output generated by the LLM.
        """
        logger.info(f"Executing prompt: {prompt}")

        # Simulate response for debugging
        #output = self._simulate_llm_response(prompt)
        output = self._obtain_llm_response(prompt)

        logger.debug(f"Received output: {output}")

        return output

    def parse_python_code(self, text_output):
        """
        Parses the LLM-generated text output to extract Python code.

        Args:
            text_output (str): The text output from the LLM.

        Returns:
            str: The extracted Python code.
        """
        logger.debug("Parsing Python code from text output")

        code_blocks = re.findall(r'```python(.*?)```', text_output, re.DOTALL)
        if not code_blocks:
            logger.warning("No Python code blocks found in the text output")
            return ''

        python_code = '\n'.join(code_blocks).strip()
        logger.debug(f"Extracted Python code: {python_code}")

        return python_code

    def adjust_score(self, adjustment):
        """
        Adjusts the model's score based on external evaluation.

        Args:
            adjustment (float): The amount to adjust the score by.
        """
        self.score_adjustments.append(adjustment)
        logger.info(f"Adjusting score by {adjustment}. Total adjustments: {self.score_adjustments}")

    def evaluate_code(self, code):
        """
        Evaluates the extracted Python code for correctness.

        Args:
            code (str): The Python code to evaluate.

        Returns:
            bool: True if the code is syntactically correct, False otherwise.
        """
        logger.info("Evaluating code")

        try:
            compile(code, '<string>', 'exec')
            logger.debug("Code is syntactically correct")
            return True
        except Exception as e:
            self.failures += 1
            logger.warning(f"Code evaluation failed: {e}. Total failures: {self.failures}")
            return False

    def get_score(self):
        """
        Calculates and returns the current score of the model.

        Returns:
            float: The current score.
        """
        logger.debug("Calculating current score")

        # Start with base score
        current_score = self.base_score

        # Apply adjustments
        total_adjustments = sum(self.score_adjustments)
        current_score += total_adjustments

        # Deduct penalties for failures
        failure_penalty = self.failures * 1.0  # Each failure deducts 1 point
        current_score -= failure_penalty

        logger.debug(f"Base score: {self.base_score}")
        logger.debug(f"Total adjustments: {total_adjustments}")
        logger.debug(f"Failure penalty: {failure_penalty}")
        logger.info(f"Current score: {current_score}")

        return current_score

    def update_base_score(self):
        """
        Recalculates the base score based on current model parameters.
        """
        logger.info("Updating base score")

        self.base_score = self._calculate_base_score()

    def _obtain_llm_response(self,prompt):
        """
        Executes LLM and parses the response.

        Args:
            prompt (str): The input prompt.

        Returns:
            str: LLM Output"""
        logger.debug("Executing LLM.")

        response = self.client.generate(model=self.model_info.get('name', 'Unknown'),
                    prompt=prompt)

        return response.get('response','')


    def _simulate_llm_response(self, prompt):
        """
        Simulates an LLM response (placeholder for actual LLM interaction).

        Args:
            prompt (str): The input prompt.

        Returns:
            str: Simulated LLM output.
        """
        logger.debug("Simulating LLM response (placeholder)")

        # This method should be replaced with actual code to interface with the LLM.
        return """
        Here is your Python code:
        ```python
        print('Hello, World!')
        ```
        """

    def __repr__(self):
        model_name = self.model_info.get('name', 'Unknown')
        return f"Model(name={model_name}, base_score={self.base_score}, current_score={self.get_score()})"


